
xmega_test_interrupt_with_AD_DA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ae  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000422  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00802000  00802000  00000422  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000422  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000454  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000050  00000000  00000000  00000494  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000050c0  00000000  00000000  000004e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003d61  00000000  00000000  000055a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005f8  00000000  00000000  00009305  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000b0  00000000  00000000  00009900  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003b82  00000000  00000000  000099b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000178  00000000  00000000  0000d532  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  0000d6aa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
   8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
   c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  10:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  14:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  18:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  1c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  20:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  24:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  28:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  2c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  30:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  34:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  38:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  3c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  40:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  44:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  48:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  4c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  50:	0c 94 18 01 	jmp	0x230	; 0x230 <__vector_20>
  54:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  58:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  5c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  60:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  64:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  68:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  6c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  70:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  74:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  78:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  7c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  80:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  84:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  88:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  8c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  90:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  94:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  98:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  9c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
  fc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 100:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 104:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 108:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 10c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 110:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 114:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 118:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 11c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 120:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 124:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 128:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 12c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 130:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 134:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 138:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 13c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 140:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 144:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 148:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 14c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 150:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 154:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 158:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 15c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 160:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 164:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 168:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 16c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 170:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 174:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 178:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 17c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 180:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 184:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 188:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 18c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 190:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 194:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 198:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 19c:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1a8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1ac:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1b8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1bc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1c8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1cc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1d8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1dc:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1e8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1ec:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f0:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f4:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>
 1f8:	0c 94 16 01 	jmp	0x22c	; 0x22c <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e3       	ldi	r29, 0x3F	; 63
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60
 20c:	18 be       	out	0x38, r1	; 56
 20e:	19 be       	out	0x39, r1	; 57
 210:	1a be       	out	0x3a, r1	; 58
 212:	1b be       	out	0x3b, r1	; 59

00000214 <__do_clear_bss>:
 214:	20 e2       	ldi	r18, 0x20	; 32
 216:	a0 e0       	ldi	r26, 0x00	; 0
 218:	b0 e2       	ldi	r27, 0x20	; 32
 21a:	01 c0       	rjmp	.+2      	; 0x21e <.do_clear_bss_start>

0000021c <.do_clear_bss_loop>:
 21c:	1d 92       	st	X+, r1

0000021e <.do_clear_bss_start>:
 21e:	a2 30       	cpi	r26, 0x02	; 2
 220:	b2 07       	cpc	r27, r18
 222:	e1 f7       	brne	.-8      	; 0x21c <.do_clear_bss_loop>
 224:	0e 94 c7 01 	call	0x38e	; 0x38e <main>
 228:	0c 94 d5 01 	jmp	0x3aa	; 0x3aa <_exit>

0000022c <__bad_interrupt>:
 22c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000230 <__vector_20>:
	}
}

// AD DA code to be run during interrupt subroutine
ISR(TCC1_OVF_vect)
{
 230:	1f 92       	push	r1
 232:	0f 92       	push	r0
 234:	0f b6       	in	r0, 0x3f	; 63
 236:	0f 92       	push	r0
 238:	11 24       	eor	r1, r1
 23a:	08 b6       	in	r0, 0x38	; 56
 23c:	0f 92       	push	r0
 23e:	18 be       	out	0x38, r1	; 56
 240:	0b b6       	in	r0, 0x3b	; 59
 242:	0f 92       	push	r0
 244:	1b be       	out	0x3b, r1	; 59
 246:	8f 93       	push	r24
 248:	9f 93       	push	r25
 24a:	ef 93       	push	r30
 24c:	ff 93       	push	r31
    PORTD.OUTTGL = (1<<7);	//Toggle Pin D7 for timing
 24e:	80 e8       	ldi	r24, 0x80	; 128
 250:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <__TEXT_REGION_LENGTH__+0x7de667>
	//	AD
	ADCA.CTRLA = ADCA.CTRLA | ADC_CH0START_bm;                  // Start Conversion
 254:	e0 e0       	ldi	r30, 0x00	; 0
 256:	f2 e0       	ldi	r31, 0x02	; 2
 258:	80 81       	ld	r24, Z
 25a:	84 60       	ori	r24, 0x04	; 4
 25c:	80 83       	st	Z, r24
	while(((ADCA.CH0.INTFLAGS & ADC_CH_CHIF_bm) == 0x00));      // Is the conversion is complete ?
 25e:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <__TEXT_REGION_LENGTH__+0x7de223>
 262:	80 ff       	sbrs	r24, 0
 264:	fc cf       	rjmp	.-8      	; 0x25e <__vector_20+0x2e>
		
	ADCA.CH0.INTFLAGS = ADC_CH_CHIF_bm;					   	    // Clear interup flag by writing a one
 266:	e0 e0       	ldi	r30, 0x00	; 0
 268:	f2 e0       	ldi	r31, 0x02	; 2
 26a:	81 e0       	ldi	r24, 0x01	; 1
 26c:	83 a3       	std	Z+35, r24	; 0x23
	AD_value = ADCA.CH0.RES;								    // Read AD Value
 26e:	84 a1       	ldd	r24, Z+36	; 0x24
 270:	95 a1       	ldd	r25, Z+37	; 0x25
 272:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
 276:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
	
	//	DA
	while ( (DACB.STATUS & DAC_CH0DRE_bm) == false );           // Wait for the DA regester to be empty
 27a:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <__TEXT_REGION_LENGTH__+0x7de325>
 27e:	80 ff       	sbrs	r24, 0
 280:	fc cf       	rjmp	.-8      	; 0x27a <__vector_20+0x4a>
	DACB.CH0DATA = AD_value; 
 282:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
 286:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
 28a:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <__TEXT_REGION_LENGTH__+0x7de338>
 28e:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <__TEXT_REGION_LENGTH__+0x7de339>

    PORTD.OUTTGL = (1<<7);	//Toggle at the end of the conversion
 292:	80 e8       	ldi	r24, 0x80	; 128
 294:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <__TEXT_REGION_LENGTH__+0x7de667>
}
 298:	ff 91       	pop	r31
 29a:	ef 91       	pop	r30
 29c:	9f 91       	pop	r25
 29e:	8f 91       	pop	r24
 2a0:	0f 90       	pop	r0
 2a2:	0b be       	out	0x3b, r0	; 59
 2a4:	0f 90       	pop	r0
 2a6:	08 be       	out	0x38, r0	; 56
 2a8:	0f 90       	pop	r0
 2aa:	0f be       	out	0x3f, r0	; 63
 2ac:	0f 90       	pop	r0
 2ae:	1f 90       	pop	r1
 2b0:	18 95       	reti

000002b2 <SP_ReadCalibrationByte>:
uint8_t SP_ReadCalibrationByte( uint8_t index )
{
	uint8_t result;

	/* Load the NVM Command register to read the calibration row. */
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 2b2:	aa ec       	ldi	r26, 0xCA	; 202
 2b4:	b1 e0       	ldi	r27, 0x01	; 1
 2b6:	92 e0       	ldi	r25, 0x02	; 2
 2b8:	9c 93       	st	X, r25
 	result = pgm_read_byte(index);
 2ba:	e8 2f       	mov	r30, r24
 2bc:	f0 e0       	ldi	r31, 0x00	; 0
 2be:	84 91       	lpm	r24, Z

	/* Clean up NVM Command register. */
 	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 2c0:	1c 92       	st	X, r1

	return result;
}
 2c2:	08 95       	ret

000002c4 <ADC_CalibrationValues_Set>:
	DAC_SingleChannel_Enable( &DACB, DAC_REFSEL_AVCC_gc, false);

}

void ADC_CalibrationValues_Set(ADC_t * adc)
{
 2c4:	cf 93       	push	r28
 2c6:	df 93       	push	r29
 2c8:	ec 01       	movw	r28, r24
	if(&ADCA == adc){
 2ca:	c1 15       	cp	r28, r1
 2cc:	82 e0       	ldi	r24, 0x02	; 2
 2ce:	d8 07       	cpc	r29, r24
 2d0:	39 f4       	brne	.+14     	; 0x2e0 <ADC_CalibrationValues_Set+0x1c>
		 /* Get ADCCAL0 from byte address 0x20 (Word address 0x10. */
		adc->CAL = SP_ReadCalibrationByte(0x20);
 2d2:	80 e2       	ldi	r24, 0x20	; 32
 2d4:	0e 94 59 01 	call	0x2b2	; 0x2b2 <SP_ReadCalibrationByte>
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	8c 87       	std	Y+12, r24	; 0x0c
 2dc:	9d 87       	std	Y+13, r25	; 0x0d
 2de:	06 c0       	rjmp	.+12     	; 0x2ec <ADC_CalibrationValues_Set+0x28>
	}else {
		/* Get ADCCAL0 from byte address 0x24 (Word address 0x12. */
		adc->CAL = SP_ReadCalibrationByte(0x24);
 2e0:	84 e2       	ldi	r24, 0x24	; 36
 2e2:	0e 94 59 01 	call	0x2b2	; 0x2b2 <SP_ReadCalibrationByte>
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	8c 87       	std	Y+12, r24	; 0x0c
 2ea:	9d 87       	std	Y+13, r25	; 0x0d
	}
}
 2ec:	df 91       	pop	r29
 2ee:	cf 91       	pop	r28
 2f0:	08 95       	ret

000002f2 <DAC_SingleChannel_Enable>:
	return result;
}


void DAC_SingleChannel_Enable( volatile DAC_t * dac, DAC_REFSEL_t convRef, bool leftAdjust )
{
 2f2:	fc 01       	movw	r30, r24
	dac->CTRLB = ( dac->CTRLB & ~DAC_CHSEL_gm ) | DAC_CHSEL_SINGLE_gc;
 2f4:	81 81       	ldd	r24, Z+1	; 0x01
 2f6:	8f 79       	andi	r24, 0x9F	; 159
 2f8:	81 83       	std	Z+1, r24	; 0x01
	dac->CTRLC = ( dac->CTRLC & ~(DAC_REFSEL_gm | DAC_LEFTADJ_bm) ) |
 2fa:	82 81       	ldd	r24, Z+2	; 0x02
 2fc:	86 7e       	andi	r24, 0xE6	; 230
 2fe:	68 2b       	or	r22, r24
 300:	46 2b       	or	r20, r22
 302:	42 83       	std	Z+2, r20	; 0x02
	             convRef | ( leftAdjust ? DAC_LEFTADJ_bm : 0x00 );
	dac->CTRLA = ( dac->CTRLA & ~DAC_CH1EN_bm ) |
 304:	80 81       	ld	r24, Z
 306:	82 7f       	andi	r24, 0xF2	; 242
 308:	85 60       	ori	r24, 0x05	; 5
 30a:	80 83       	st	Z, r24
 30c:	08 95       	ret

0000030e <ioinit>:
}

void ioinit (void)
{

	PORTB_DIR = 0b00000100;  // DACB DAC0 Set as Output
 30e:	84 e0       	ldi	r24, 0x04	; 4
 310:	80 93 20 06 	sts	0x0620, r24	; 0x800620 <__TEXT_REGION_LENGTH__+0x7de620>
		
	// Set 32MHz clock
	OSC.CTRL = OSC_RC32MEN_bm; 				//enable 32MHz oscillator 
 314:	82 e0       	ldi	r24, 0x02	; 2
 316:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
    while(!(OSC.STATUS & OSC_RC32MRDY_bm));	//wait for stability 
 31a:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7de051>
 31e:	81 ff       	sbrs	r24, 1
 320:	fc cf       	rjmp	.-8      	; 0x31a <ioinit+0xc>
    CCP = CCP_IOREG_gc; 					//secured access 
 322:	88 ed       	ldi	r24, 0xD8	; 216
 324:	84 bf       	out	0x34, r24	; 52
    CLK.CTRL = 0x01; 						//choose this osc source as clk 
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7de040>

	// AD

	// Move stored calibration values to ADC A.
	ADC_CalibrationValues_Set(&ADCA);
 32c:	80 e0       	ldi	r24, 0x00	; 0
 32e:	92 e0       	ldi	r25, 0x02	; 2
 330:	0e 94 62 01 	call	0x2c4	; 0x2c4 <ADC_CalibrationValues_Set>

	// Set up ADC A to have signed (true) or Unsigned (false) conversion mode and 12 bit resolution. 
	ADC_ConvMode_and_Resolution_Config(&ADCA, false, ADC_RESOLUTION_12BIT_gc);
 334:	e0 e0       	ldi	r30, 0x00	; 0
 336:	f2 e0       	ldi	r31, 0x02	; 2
 338:	81 81       	ldd	r24, Z+1	; 0x01
 33a:	89 7e       	andi	r24, 0xE9	; 233
 33c:	81 83       	std	Z+1, r24	; 0x01

	// Set referance voltage on ADC A to be Internal 1 volt
	ADC_Referance_Config(&ADCA, ADC_REFSEL_INT1V_gc);
 33e:	82 81       	ldd	r24, Z+2	; 0x02
 340:	8f 78       	andi	r24, 0x8F	; 143
 342:	82 83       	std	Z+2, r24	; 0x02

	// Sample rate is CPUFREQ/256. Allow time for storing data.
	ADC_Prescaler_Config(&ADCA, ADC_PRESCALER_DIV16_gc);
 344:	84 81       	ldd	r24, Z+4	; 0x04
 346:	88 7f       	andi	r24, 0xF8	; 248
 348:	82 60       	ori	r24, 0x02	; 2
 34a:	84 83       	std	Z+4, r24	; 0x04

	// Setup channel 2  to have singleended input. 
	ADC_Ch_InputMode_and_Gain_Config(&ADCA.CH0,
 34c:	a0 e2       	ldi	r26, 0x20	; 32
 34e:	b2 e0       	ldi	r27, 0x02	; 2
 350:	8c 91       	ld	r24, X
 352:	80 7e       	andi	r24, 0xE0	; 224
 354:	81 60       	ori	r24, 0x01	; 1
 356:	8c 93       	st	X, r24
									 ADC_CH_INPUTMODE_SINGLEENDED_gc,
	                                 ADC_CH_GAIN_1X_gc);

	// Set input to the channels in ADC A to be PIN 3
	ADC_Ch_InputMux_Config(&ADCA.CH0, ADC_CH_MUXPOS_PIN3_gc, ADC_CH_MUXNEG_PIN2_gc);
 358:	8a e1       	ldi	r24, 0x1A	; 26
 35a:	11 96       	adiw	r26, 0x01	; 1
 35c:	8c 93       	st	X, r24

	// Enable Enable AD Conversion in ADC A
	ADC_Enable(&ADCA);
 35e:	80 81       	ld	r24, Z
 360:	81 60       	ori	r24, 0x01	; 1
 362:	80 83       	st	Z, r24


	// DA

	// Setup DAC channel B with the DA reference set to the Analog supply voltage and DA data left adjust false 
	DAC_SingleChannel_Enable( &DACB, DAC_REFSEL_AVCC_gc, false);
 364:	40 e0       	ldi	r20, 0x00	; 0
 366:	68 e0       	ldi	r22, 0x08	; 8
 368:	80 e2       	ldi	r24, 0x20	; 32
 36a:	93 e0       	ldi	r25, 0x03	; 3
 36c:	0e 94 79 01 	call	0x2f2	; 0x2f2 <DAC_SingleChannel_Enable>
 370:	08 95       	ret

00000372 <timer_init>:
	dac->CTRLA = ( dac->CTRLA & ~DAC_CH1EN_bm ) |
	             DAC_CH0EN_bm | DAC_ENABLE_bm;
}

void timer_init(uint16_t topCount)
{
 372:	9c 01       	movw	r18, r24
	TCC1.CTRLB |= TC_WGMODE_NORMAL_gc;		//Normal mode, Output Compare pins disconnected
 374:	e0 e4       	ldi	r30, 0x40	; 64
 376:	f8 e0       	ldi	r31, 0x08	; 8
 378:	81 81       	ldd	r24, Z+1	; 0x01
 37a:	81 83       	std	Z+1, r24	; 0x01
	TCC1.INTCTRLA |= TC_OVFINTLVL_LO_gc;	//Enable overflow interrrupt
 37c:	96 81       	ldd	r25, Z+6	; 0x06
 37e:	91 60       	ori	r25, 0x01	; 1
 380:	96 83       	std	Z+6, r25	; 0x06
	TCC1.PER = topCount;					//Set Period
 382:	26 a3       	std	Z+38, r18	; 0x26
 384:	37 a3       	std	Z+39, r19	; 0x27
	TCC1.CTRLA |= TC_CLKSEL_DIV4_gc;		//Start at Clk/4
 386:	80 81       	ld	r24, Z
 388:	83 60       	ori	r24, 0x03	; 3
 38a:	80 83       	st	Z, r24
 38c:	08 95       	ret

0000038e <main>:
int main(void)
{
    unsigned int topCount;
    float Ts;

    ioinit();
 38e:	0e 94 87 01 	call	0x30e	; 0x30e <ioinit>

    PORTD.DIRSET = (1<<7); //set PD7 as output for timing pin
 392:	80 e8       	ldi	r24, 0x80	; 128
 394:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x7de661>

    Ts = 0.001; //Start with 1k Hz for now seeing if the code works 
	topCount = (uint16_t)(Ts*8000000.);		//Computed TOP value for TCC1

	timer_init(topCount);
 398:	80 e4       	ldi	r24, 0x40	; 64
 39a:	9f e1       	ldi	r25, 0x1F	; 31
 39c:	0e 94 b9 01 	call	0x372	; 0x372 <timer_init>
	
	//enable intterupts all levels
	PMIC.CTRL = PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
 3a0:	87 e0       	ldi	r24, 0x07	; 7
 3a2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7de0a2>
	sei();
 3a6:	78 94       	sei
 3a8:	ff cf       	rjmp	.-2      	; 0x3a8 <main+0x1a>

000003aa <_exit>:
 3aa:	f8 94       	cli

000003ac <__stop_program>:
 3ac:	ff cf       	rjmp	.-2      	; 0x3ac <__stop_program>
